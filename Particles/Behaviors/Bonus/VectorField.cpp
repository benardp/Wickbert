//@file VectorField.cpp
//@author Generated by PSL


#include "VectorField.h"
#include "ParticlePosition.h"
#include "ParticleVelocity.h"
#include <fstream>

REGISTER_PARTICLESTUFF(VectorField,"Behavior:VectorField");

// default constructor
VectorField::VectorField(Particles *ps)
	: ParticleBehavior(ps, std::string("VectorField"))
	, minCorner(-10,-10,-10)
	, maxCorner(10,10,10)
	, boxSize(maxCorner-minCorner)
	, gridSize(32)
	, stepSize(boxSize/gridSize)
{
	scaler = 1.0;
	readData(std::string("vortex32_0.txt"));
}

int VectorField::qlen()
{
	return 1;
}

void VectorField::getq(double *q)
{
	q[0] = scaler;
}

void VectorField::setq(double *q)
{
	scaler = q[0];
}

void VectorField::qname(char **qn)
{
	qn[0] = "scaler";
}

int VectorField::qlenpp()
{
	return 3;
}

void VectorField::getqpp(double *q, int i)
{
	gmVector3 v=getVector(position->getPosition(i));
	q[0] = v[0];
	q[1] = v[1];
	q[2] = v[2];
}

void VectorField::setqpp(double *q, int i)
{
	// cannot be changed
}

void VectorField::qnamepp(char **qn)
{
	qn[0] = "vectorField[0]";
	qn[1] = "vectorField[1]";
	qn[2] = "vectorField[2]";
}

void VectorField::applyForce()
{
	for(unsigned int i=0;i<ps->size();++i)
	{
		velocity->v[i]+=scaler*getVector(position->getPosition(i));
	}
}

gmVector3 VectorField::getVector(const gmVector3 &position)
{
	// use nearest
	// later I should try interpolation
	int x=(position-minCorner)[0]/stepSize[0];
	int y=(position-minCorner)[1]/stepSize[1];
	int z=(position-minCorner)[2]/stepSize[2];
	if (x<0) return gmVector3(0,0,0);
	if (y<0) return gmVector3(0,0,0);
	if (z<0) return gmVector3(0,0,0);
	if (x>=gridSize) return gmVector3(0,0,0);
	if (y>=gridSize) return gmVector3(0,0,0);
	if (z>=gridSize) return gmVector3(0,0,0);
	return data[x][y][z];
}


void VectorField::readData(std::string filename)
{
	// read from file
	std::ifstream file(filename.c_str());
	double sx,sy,sz;
	// error opening file
	if (!file)
	{
		// creating temporary data
		for(unsigned int x=0; x<gridSize; ++x)
		for(unsigned int y=0; y<gridSize; ++y)
		for(unsigned int z=0; z<gridSize; ++z)
		{
			gmVector3 position(minCorner+gmVector3(x*stepSize[0],y*stepSize[1],z*stepSize[2]));
			data[x][y][z]=-position;
		}
		std::cout << "VectorField::readData, error opening file " <<
			filename <<". created temporary vector field."<< std::endl;
		return;
	}
	// read data
	for(unsigned int x=0; x<gridSize; ++x)
	for(unsigned int y=0; y<gridSize; ++y)
	for(unsigned int z=0; z<gridSize; ++z)
	{
		if (file.eof())
		{
			std::cout << "VectorField::readData, unexpected end of file." << std::endl;
			return;
		}
		file >> sx;
		file >> sy;
		file >> sz;
		data[x][y][z].assign(sx,sy,sz);
	}
}